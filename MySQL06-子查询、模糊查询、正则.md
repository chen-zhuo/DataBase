# 子查询、模糊查询、正则

### 子查询

**SQL允许创建子查询（subquery），即嵌套在其他查询中的查询。**

##### 子查询过滤

```sql
-- 1.查询'字段2'的值为year的所有行其中字段1的值(假如查询结果为：2008,2020)
SELECT 字段1 FROM 表名 WHERE 字段2 = 'year';
-- 2.根据上面的查询结果，查询'字段1'的值为'2008'和'2020'的所有行的字段3的值
SELECT 字段3 FROM 表名 WHERE 字段1 IN ('2008', '2020');

-- 将上面两次查询写成一个子查询
SELECT 字段3 FROM 表名 WHERE 字段1 IN (SELECT 字段1 FROM 表名 WHERE 字段2 = 'year');
```

?> 在 `SELECT` 语句中，子查询总是从内向外处理。

?> 虽然子查询一般与IN操作符结合使用，但也可以用于测试等于（=）、不等于（<>）等。

!> 在 `WHERE` 子句中使用子查询能够编写出功能很强并且很灵活的SQL语句。对于能嵌套的子查询的数目没有限制，不过在实际使用时由于性能的限制，不能嵌套太多的子查询。

##### 子查询计算

```sql
-- SELECT COUNT(*)对表中的行进行计数
-- GROUP BY 字段是对字段进行分组
-- 'NEW_字段'是一个计算字段，它是由圆括号中的子查询建立的。该子查询对检索出的每行各执行一次。
SELECT 字段 (SELECT COUNT(*) FROM 表名 WHERE 字段 = '1') AS NEW_字段 FROM 表名 GROUP BY 字段; 
```

### 模糊查询

前面介绍的所有操作符都是针对已知值进行过滤的。但是，这种过滤方法并不是任何时候都好用。例如，怎样搜索字符串中包含'jet'的所有字符串？用简单的比较操作符肯定不行，必须使用通配符。

##### 模糊查询组成

`LIKE`：**模糊查询关键字，后面跟搜索条件。**

通配符(wildcard)：**结合 `LIKE` 操作符来匹配值的一部分的特殊字符**。

搜索模式(search pattern)：**由字面值、通配符或两者组合构成的搜索条件。**

##### 百分号`%`通配符

百分号`%`：**匹配出现任意次数的任意字符（NULL除外）。**

```sql
-- 检索任意以jet起头的字符串，不管后面是什么字符和有多少字符
SELECT * FROM 表名 WHERE 字段名 LIKE 'jet%';

-- 检索任意位置包含jet的字符串，而不论它之前或之后出现什么字符。
SELECT * FROM 表名 WHERE 字段名 LIKE '%jet%';

-- 检索以j起头，以t结尾的字符串，而不论中间出现什么字符。
SELECT * FROM 表名 WHERE 字段名 LIKE 'j%t';
```

!> MySQL检索可以选择区分大小写的。如果区分，`jet%` 与 `Jet...` 将不匹配。

!> 百分号`%`除了匹配一个或多个字符外，还能匹配0个字符。

!> 字符串尾空格可能会干扰通配符匹配，检索时最好在最后附加一个百分号(%)。

##### 下划线`_`通配符

下划线`_`：**匹配出现任意的单个字符。**

```sql
-- 检索任意以jet起头，长度为4的所有行
SELECT * FROM 表名 WHERE 字段名 LIKE 'jet_';

-- 检索任意以jet结尾，长度为4的所有行
SELECT * FROM 表名 WHERE 字段名 LIKE '_jet';

-- 检索第一个、最后一个字符为任意字符，中间字符为jet，长度为5的所有行
SELECT * FROM 表名 WHERE 字段名 LIKE '_jet_';
```

!> 下划线(_)必须要匹配到一个字符，不能多也不能少。

##### 使用技巧

通配符很有用，但通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧：

1. **不要过度使用通配符。**如果其他操作符能达到相同的目的，应该使用其他操作符。
2. **通配符不要用在搜索模式的开始处。**除非绝对有必要，否则搜索起来是最慢的。
3. **注意通配符的位置。**如果放错地方，可能不会返回想要的数据。

### 正则表达式

> 所有种类的程序设计语言、文本编辑器、操作系统等都支持正则表达式。

用匹配、比较和通配操作符寻找数据，对于基本的过滤，基本就足够了。但随着过滤条件的复杂性的增加，`WHERE` 子句本身的复杂性也增加。这也就是正则表达式变得有用的地方。

`REGEXP`：**正则表达式关键字，后面跟正则表达式。**

!> `LIKE`和`REGEXP`的不同在于，`LIKE`匹配整个串而`REGEXP`匹配子串。

##### 基本字符匹配

```sql
-- 检索字段中包含jet的所有行
SELECT * FROM 表名 WHERE 字段名 REGEXP 'jet';

-- 检索任意以jet起头，长度为4的所有行
SELECT * FROM 表名 WHERE 字段名 REGEXP 'jet.';
```

!> `LIKE 'jet'` 匹配列值中等于 `jet` 所有行，`REGEXP 'jet'` 匹配列值中包含 `jet` 的所有行。

?> MySQL中的正则表达式匹配（自版本3.23.4后）不区分大小写）。需要区分大小写，可使用 `BINARY` 关键字，如 `WHERE 字段名 REGEXP BINARY '正则表达式'`。

##### 或`|`匹配

或`|`：**使用一个或者另一个正则表达式去匹配字符串。**

```sql
-- 检索字段中包含jet或cat或cat的所有行
SELECT * FROM 表名 WHERE 字段名 REGEXP 'jet|cat|hat';
```

##### 单`[]`匹配

单`[]`：**匹配出现在 `[]` 中的任意单个字符。**

```sql
-- 检索字段中包含hao1或hao2或hao3的所有行
SELECT * FROM 表名 WHERE 字段名 REGEXP 'hao[123]';
```

**结合或 `|` 匹配，还可以匹配字符串**：

```sql
-- 检索字段中包含hao1或hao23的所有行
SELECT * FROM 表名 WHERE 字段名 REGEXP 'hao[1|23]';
```

**结合 `^` 匹配，还可以匹配不在 `[]` 中的任意单个字符：**

```sql
-- 检索字段中包含hao但除开hao1或hao2或hao3外的所有行
SELECT * FROM 表名 WHERE 字段名 REGEXP 'hao[^123]';
```

**在 `[]` 内匹配范围，简化集合，可使用 `-` 来定义一个范围：**

```
匹配任意数字字符：[0-9]，即[0123456789]
匹配任意字母字符：[a-z]
```

##### 多实例匹配

目前为止使用的所有正则表达式都试图匹配单次出现，如果需要对匹配的数目进行更强的控制，就需要使用重复元字符来进行匹配了。

| 元字符 |             说明             |
| :----: | :--------------------------: |
|   *    |        0个或多个匹配         |
|   +    |  1个或多个匹配（等于{1,}）   |
|   ?    |  0个或1个匹配（等于{0,1}）   |
|  {n}   |        指定数目的匹配        |
|  {n,}  |     不少于指定数目的匹配     |
| {n,m}  | 匹配数目的范围（m不超过255） |

##### 特殊`\\`匹配

正则表达式由具有特定含义的特殊字符构成，例如`.、[]、 |和-`等，如果需要匹配这些字符，就需要在前面加上特殊引导符`\\`。

```sql
-- 检索字段中包含.的所有行
SELECT * FROM 表名 WHERE 字段名 REGEXP '\\.';

-- 检索字段中包含-的所有行
SELECT * FROM 表名 WHERE 字段名 REGEXP '\\-';

-- 检索字段中包含\的所有行
SELECT * FROM 表名 WHERE 字段名 REGEXP '\\\';
```

`\\`也用来引用元字符：

| 元字符 |   说明   |
| :----: | :------: |
|  \\\f  |   换页   |
|  \\\n  |   换行   |
|  \\\r  |   回车   |
|  \\\t  |   制表   |
|  \\\v  | 纵向制表 |

##### 字符类匹配

字符类(character class)：预定义的字符集，可以更方便找出你自己经常使用的数字、所有字母字符或所有数字字母字符等的匹配。

|     类     |                       说明                        |
| :--------: | :-----------------------------------------------: |
| [:alnum:]  |          任意字母和数字（同[a-zA-Z0-9]）          |
| [:alpha:]  |              任意字符（同[a-zA-Z]）               |
| [:blank:]  |               空格和制表（同[\\t]）               |
| [:cntrl:]  |         ASCII控制字符（ASCII 0到31和127）         |
| [:digit:]  |                任意数字（同[0-9]）                |
| [:graph:]  |           与[:print:]相同，但不包括空格           |
| [:lower:]  |              任意小写字母（同[a-z]）              |
| [:print:]  |                  任意可打印字符                   |
| [:punct:]  |    既不在[:alnum:]又不在[:cntrl:]中的任意字符     |
| [:space:]  | 包括空格在内的任意空白字符（同[\\f\\n\\r\\t\\v]） |
| [:upper:]  |              任意大写字母（同[A-Z]）              |
| [:xdigit:] |         任意十六进制数字（同[a-fA-F0-9]）         |

```sql
-- 匹配含有连在一起的4位数字的所有行
SELECT * FROM 表名 WHERE 字段名 REGEXP '[[:digit:]]{4}';
```

##### 定位符

定位符：匹配特定位置的文本。

| 元 字 符 |   说 明    |
| :------: | :--------: |
|    ^     | 文本的开始 |
|    $     | 文本的结尾 |
| [[:<:]]  |  词的开始  |
| [[:>:]]  |  词的结尾  |

```sql
-- 匹配以任意数字或者.开头的文本的所有行
SELECT * FROM 表名 WHERE 字段名 REGEXP '^[0-9\\.]';
```

!> **^**有双重用途：在集合中（用[和]定义），用它来否定该集合，否则，用来指串的开始处。





















