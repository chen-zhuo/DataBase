# 操作MySQL

### 连接配置

##### 启动MySQL服务

在命令行窗口输入:

```
net start mysql
```

##### 安装pymysql

```
pip install pymysql
```

##### 配置连接参数

最好将mysql的连接、操作游标定义成全局变量，方便函数调用。

```
# 导入pymysql
import pymysql

# 主机地址
host = '127.0.0.1'
# 用户名
user = 'root'
# 密码
password = '5335915'
# 数据库名称
database = 'test'
# 连接数据库的默认端口
port = 3306
# 生成连接db
db = pymysql.connect(host, user, password, database, charset='utf8', port=port)
# 生操作游标cursor
cursor = db.cursor()
```

**坑：cursor和db.cursor()是有区别的，使用cursor去执行后面的sql语句，就使用一个操作游标，如果频繁的调用db.cursor()去去执行sql语句，会生成多个操作游标，还可能会报错。**

### 操作数据库

**注意：操作数据库是操作游标来执行的，提交执行结果是连接来执行的。**

##### 执行SQL语句

**提示：使用execute()方法执行sql语句。**

```
sql1 = "CREATE TABLE USER( Id INT PRIMARY KEY AUTO_INCREMENT, 
						  NAME VARCHAR(10), 
						  HOBBY VARCHAR(100)
						 )"
cursor.execute(sql1)
# 这里就在名为test的数据库中创建了一张名为USER的表，表中三个字段，id字段为主键、自增型，NAME字段为字符串最大长度为10，HOBBY字段为字符串最大长度为100.

name = 'chen'
hobby = 'sport'
sql2 = 'INSERT INTO USER(NAME,HOBBY) VALUES("%s","%s")' % (name,hobby)
cursor.execute(sql2)
#这里向USER表中NAME和HOBBY字段中插入了变量name和hobby的值。（%s代表插入的变量是字符型）

sql3 = "INSERT INTO USER(NAME,HOBBY) VALUES("zhuo","computer")"
cursor.execute(sql3)
#这里向USER表中NAME和HOBBY字段中插入了zhuo和computer的字符串。

db.commit()
# 提交操作数据，若不提交，则表中没有数据
```

##### 动态数据插入

数据的插入是通过SQL语句实现的

```
sql = 'INSERT INTO students(id, name, age) values(%s, %s, %s)
```

有一个极其不方便的地方，比如突然增加了某一个字段sex，此时SQL语句就要改成：

	sql = 'INSERT INTO students(id, name, age, sex) values(%s, %s, %s, %s)
这显然不是我们想要，这时我们就需要一个通用的插入动态变化的字典的方法：

```
table = 'students'
data = {
        'id': 1,
        'name': 'chen',
        'age': 20
    	}
keys = ','.join(data.keys())
values = ','.join(['%s'] * len(data))

sql = f'INSERT INTO {table}({keys}) VALUES({values})'
    
try:
   if cursor.execute(sql, tuple(data.values())):
     	print('Successful')
        db.commit()
except:
   print('Failed')
   db.rollback()
```

##### SQL语句结果

```
# sql查询语句
sql = f'SELECT cookie FROM 表名 WHERE 条件语句'
# 执行sql
cursor.execute(sql)
# 将执行结果保存在res
res = cursor.fetchall()
# 结果形式是大元祖包含小元祖，每个小元祖里面包含一个结果和一个空
print(res)				# ((结果1,),(结果2,),(结果3,),...)
print(res[0][0])		# 结果1
```

##### 关闭MySQL连接

```
db.close()
# 关闭数据库连接
```

**注意：不要写在循环中，若频繁的关闭数据库，可能会导致数据库崩溃。**

# 操作MongoDB

### 连接配置

##### 启动MongoDB服务

在命令行窗口输入：

```
net start mongodb
```

##### 安装pymongo

```
pip install pymongo
```

##### 配置连接参数

```
# 导入pymongo
from pymongo import MongoClient

# 连接本地的数据库
client = MongoClient()
# 连接其他机器的数据库
client = MongoClient('mongodb://主机IP:27017')
client = MongoClient(host='主机IP', port = 27017)
```

### 操作数据库

##### 操作游标

```
# 假设要连接的数据库名为:primer
db = client.primer
db = client['primer']
# 连接到对应的数据表
coll = db.dataset
coll = db['dataset']
```

##### 插入数据

```
# 插入数据
coll.insert(document)
# 插⼊一条数据
coll.insert_one(document)
# 插入多条数据
coll.insert_many(documents, ordered=True)

# 插入数据 students 这个集合，新建一条学生数据，这条数据以字典形式表示：
student = { 
	’id ’:’ 20170101 ’, 
	’name ':’Jordan ’,
	’ age ’, 20, 
	’gender’:’male ’ 
			}

result = coll.insert(student) 
print(result) 	# 932a68615c2606814c91f3d

# 在MongoDB 中，每条数据其实都有一个＿id 属性来唯一标识。如果没有显式指明该属性，MongoDB会自动产生一个 ObjectId 类型的＿id 属性。insert()方法会在执行后返回＿id值。
```

##### 查询数据

```
# find 查询出来的是⼀个列表集合
# 查询所有数据
cursor = coll.find()
# 查询字段是最上层的
cursor = coll.find({“borough”: “Manhattan”})
# 查询字段在内层嵌套中
cursor = coll.find({“address.zipcode”: “10075”})
# 操作符查询
cursor = coll.find({“grades.score”: {“$gt”: 30}})
cursor = coll.find({“grades.score”: {“$lt”: 10}})
AND
cursor = coll.find({“cuisine”: “Italian”, “address.zipcode”: “10075”})
cursor = coll.find({“$or”: [{“cuisine”: “Italian”}, {“address.zipcode”: “10075”}]})

# find_one，查找一条数据，返回的是⼀个JSON式⽂档，所以可以直接使⽤！

### sort排序时要特别注意，使⽤的并不是和mongo shell的⼀样，⽽是使⽤了列表，
### 当排序的标准只有⼀个，且是递增时，可以直接写在函数参数中：
pymongo.ASCENDING = 1
pymongo.DESCENDING = -1
cursor = coll.find().sort(“borough”)
cursor = coll.find().sort([(“borough”, pymongo.ASCENDING),(“address.zipcode”, pymongo.DESCENDING)])
```

##### 修改数据

```
# 更新⽂档的函数有三个(不能更新_id字段)
update_one(filter, update, upsert=False)
update_many(filter, update, upsert=False)
replace_one(filter, replacement, upsert=False)
find_one_and_update(filter, update, projection=None, sort=None, 
return_document=ReturnDocument.BEFORE, **kwargs)

# update_one返回结果是⼀个：UpdateResult ，如果查找到多个匹配，则只更新第⼀个！
result = coll.update_one(
 {“name”: “Juni”},
 {
 “$set”: {
 “cuisine”: “American (New)”
 },
 “$currentDate”: {“lastModified”: True}
 }
)
update_many
# 查找到多少匹配，就更新多少。
result = coll.update_many(
 {“address.zipcode”: “10016”, “cuisine”: “Other”},
 {
 “$set”: {“cuisine”: “Category To Be Determined”},
 “$currentDate”: {“lastModified”: True}
 }
)
```

##### 删除数据

```
删除⼀个
result = coll.delete_one({‘x’: 1})
删除多个
result = coll.delete_many({“borough”: “Manhattan”})
删除全部
result = coll.delete_many({})
删除整个集合，是drop_collection()的别名
coll.drop()
```

# 操作Redis

### 连接配置

##### 安装Redis 

```
pip install Redis
```

##### 安装redis-py

redis-py 库提供两个类 Redis 和 StrictRedis 来实现 Redis 的命令操作。

StrictRedis 实现了绝大部分官方的命令，参数一一对应(官方推荐)。

Redis是StrictRedis 的子类，它的主要功能是用于向后兼容旧版本库里的几个方法。

```
pip install redis-py
```

##### 连接Redis	

现在我们已经在本地安装了 Redis 并运行在 6379 端口，密码默认为None。那么，可以用如下示例连接 Redis 并测试：

```
# 导入redis
import redis

# 声明 StrictRedis 对象，默认传入地址localhost、端口6379、选择0号数据库（不写默认0号）、密码为None。
con = redis.StrictRedis(host='localhost', port=6379, db='0', password='None')
```

### 操作数据库

##### 键值对string
```
# set()方法，设置一个键值对
con.set('name', 'Bob') 

# 获取键值并打印
print(con.get('name')) 	# b'Bob'
```

##### 集合set

```
# 集合save_url中加入123456
con.sadd('save_url','123456')

# 判断集合save_url是否存在123456
print(con.sismember('save_url','123456'))    # True

# 集合save_url中删除123456
con.srem('save_url','123456')

# 判断集合save_url是否存在123456
print(con.sismember('save_url','123456'))    # False
```
